/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=addDifferentPrimaryKeys_4037abe696
ROOST_METHOD_SIG_HASH=addDifferentPrimaryKeys_db1899115c
"""
  Scenario 1: Test adding different primary keys to existing tables.
  Details:
    TestName: addDifferentPrimaryKeysToExistingTables.
    Description: This test checks if the function correctly adds different primary keys to existing tables in both snapshots.
  Execution:
    Arrange: Set up variables such as firstSnapshotName, secondSnapshotName, firstPrimaryKey, secondPrimaryKey, and table with valid values.
    Act: Invoke addDifferentPrimaryKey() method with the provided parameters.
    Assert: Check if the primaryKeys have been added to both snapshots using the proper tables.
  Validation:
    This test ensures that given primary keys are successfully added to specified table names in both snapshots. It verifies the functionality where different primary keys are meant to be added to snapshots.

  Scenario 2: Test adding different primary keys to non-existent tables.
  Details:
    TestName: addDifferentPrimaryKeysToNonExistentTables.
    Description: This test checks if the function provides error handling when trying to add primary keys to tables that do not exist.
  Execution:
    Arrange: Set up variables such as firstSnapshotName, secondSnapshotName, firstPrimaryKey, secondPrimaryKey, and table with a non-existent table name.
    Act: Invoke addDifferentPrimaryKey() method with the provided parameters.
    Assert: Check if an exception or error message is thrown.
  Validation:
    This test validates the functionality where different primary keys are supposed to be added to snapshots but the table doesn't exist.
  Scenario 3: Test adding different primary keys with empty snapshot or table args.
  Details:
    TestName: addDifferentPrimaryKeysWithEmptyArgs.
    Description: This test ensures the functionality of the method when it receives empty snapshot names or table.
  Execution:
    Arrange: Set up variables such as firstSnapshotName, secondSnapshotName, firstPrimaryKey, secondPrimaryKey, and table with an empty values.
    Act: Invoke addDifferentPrimaryKey() method with the provided parameters.
    Assert: Check if an exception or error message is thrown.
  Validation:
    This test validates the functionality where different primary keys are supposed to be added to snapshots or tables, but the argument is missing or empty.
"""
*/
// ********RoostGPT********
package com.axway.ats.common.dbaccess.snapshot.equality;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.BeforeEach;
import java.util.Map;
import java.util.TreeMap;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertThrows;
import java.util.ArrayList;
import java.util.List;
import com.axway.ats.common.PublicAtsApi;
import org.junit.jupiter.api.*;

@Tag("com.axway.ats.common.dbaccess.snapshot.equality")
@Tag("com.axway.ats.common.dbaccess.snapshot.equality.addDifferentPrimaryKeys")
@Tag("com.axway.ats.common.dbaccess.snapshot.equality.addDifferentPrimaryKey")
public class DatabaseEqualityStateAddDifferentPrimaryKeysTest {

	private DatabaseEqualityState des;

	@BeforeEach
	public void setup() {
		des = new DatabaseEqualityState("snapshot1", "snapshot2");
	}

	@Test
	@Tag("valid")
	public void addDifferentPrimaryKeysToExistingTables() {
		String table = "testTable";
		String firstPrimaryKey = "pk1";
		String secondPrimaryKey = "pk2";
		des.addDifferentPrimaryKeys("snapshot1", "snapshot2", firstPrimaryKey, secondPrimaryKey, table);

		Map<String, String> firstSnapshotKeys = des.getDifferentPrimaryKeys().get("snapshot1");
		Map<String, String> secondSnapshotKeys = des.getDifferentPrimaryKeys().get("snapshot2");
		assertTrue(firstSnapshotKeys.get(table).equals(firstPrimaryKey));
		assertTrue(secondSnapshotKeys.get(table).equals(secondPrimaryKey));
	}

	@Test
	@Tag("invalid")
	public void addDifferentPrimaryKeysToNonExistentTables() {
		String nonExistentTable = "nonExistentTable";
		String firstPrimaryKey = "pk3";
		String secondPrimaryKey = "pk4";
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("snapshot1", "snapshot2", firstPrimaryKey, secondPrimaryKey, nonExistentTable);
		});
	}

	@Test
	@Tag("boundary")
	public void addDifferentPrimaryKeysWithEmptyArgs() {
		String table = "testTable";
		String firstPrimaryKey = "pk5";
		String secondPrimaryKey = "pk6";
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("", "snapshot2", firstPrimaryKey, secondPrimaryKey, table);
		});
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("snapshot1", "", firstPrimaryKey, secondPrimaryKey, table);
		});
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("snapshot1", "snapshot2", "", secondPrimaryKey, table);
		});
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("snapshot1", "snapshot2", firstPrimaryKey, "", table);
		});
		assertThrows(IllegalArgumentException.class, () -> {
			des.addDifferentPrimaryKeys("snapshot1", "snapshot2", firstPrimaryKey, secondPrimaryKey, "");
		});
	}

}