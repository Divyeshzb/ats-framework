/*
 * Copyright 2017 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=dateToString_c39ae438d7
ROOST_METHOD_SIG_HASH=dateToString_b858ffe026
Scenario 1: Valid TimeInMillis Data
  Details:
    TestName: testValidTimeInMillis
    Description: Test if the "dateToString" method correctly converts timeInMillis to the correct String format.
  Execution:
    Arrange: Instantiate a long variable with the test value, and calculate the corresponding expected string.
    Act: Call the "dateToString" method with the long variable.
    Assert: Verify if the returned string matches the calculated expected string.
  Validation:
    Checks if the time in milliseconds can be properly converted to a string with a specific format. This is important as it will be presented or stored in this format.
Scenario 2: TimeInMillis as Zero
  Details:
    TestName: testZeroAsTimeInMillis
    Description: Test if the "dateToString" method correctly converts the epoch (0 milliseconds from 1970-01-01) to the correct String date.
  Execution:
    Arrange: Set a long variable to 0, and calculate the corresponding string date.
    Act: Call the "dateToString" method with the long variable.
    Assert: Verify if the returned string portrays the correct date for the epoch.
  Validation:
    Validates if the method works correctly even for edge cases like converting the initial UNIX time into date format. It's crucial to ensure that the method can handle lower boundary cases.
Scenario 3: Negative TimeInMillis
  Details:
    TestName: testNegativeAsTimeInMillis
    Description: Test if the "dateToString" method correctly manages negative values of timeInMillis.
  Execution:
    Arrange: Set a long variable to a negative value.
    Act: Call the "dateToString" method with the negative long.
    Assert: Check if an appropriate exception is thrown or if it converts to a date prior to the epoch.
  Validation:
    Verifies that the method can handle invalid or unexpected values, either by rejecting these inputs or by handling them sensibly. This is important for the robustness of the code.
Scenario 4: Test with Maximum Possible Milliseconds
  Details:
    TestName: testMaxPossibleTimeInMillis
    Description: Test if the "dateToString" method correctly converts the maximum long value to the correct String date format.
  Execution:
    Arrange: Set a long variable to Long.MAX_VALUE, and calculate the corresponding string date.
    Act: Call the "dateToString" method with the long variable.
    Assert: Verify if the returned string portrays the correct maximum possible date.
  Validation:
    Checks that the method can handle upper boundary inputs and returns a sensible result. This validates robustness in the presence of potentially unforeseen values.
Scenario 5: Null TimeInMillis
  Details:
    TestName: testNullTimeInMillis
    Description: Test if the method handles null input gracefully and does not throw an unexpected exception.
  Execution:
    Arrange: Set a long variable to null.
    Act: Call the "dateToString" method with the null long.
    Assert: Check if an appropriate exception or error is thrown or handled.
  Validation:
    The method must be robust against null input, which could occur in case of a missing or corrupted value. This checks the method's fail-safe approach against invalid inputs.
*/
// ********RoostGPT********
package com.axway.ats.common.dbaccess.snapshot;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.ArrayList;
import java.util.List;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.junit.jupiter.api.*;

@Tag("com.axway.ats.common.dbaccess.snapshot")
@Tag("com.axway.ats.common.dbaccess.snapshot.dateToString")
public class DatabaseSnapshotUtilsDateToStringTest {

	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ");

	@Test
	@Tag("valid")
	public void testValidTimeInMillis() {
		long testTime = 1633568507000L;
		String expected = "2021-10-07 00:15:07.000+0000";
		String actualTime = DatabaseSnapshotUtils.dateToString(testTime);
		Assertions.assertEquals(expected, actualTime);
	}

	@Test
	@Tag("boundary")
	public void testZeroAsTimeInMillis() {
		long testTime = 0L;
		String expected = "1970-01-01 00:00:00.000+0000";
		String actualTime = DatabaseSnapshotUtils.dateToString(testTime);
		Assertions.assertEquals(expected, actualTime);
	}

	@Test
	@Tag("invalid")
	public void testNegativeAsTimeInMillis() {
		long testTime = -1633568507000L;
		Assertions.assertThrows(IllegalArgumentException.class, () -> DatabaseSnapshotUtils.dateToString(testTime));
	}

	@Test
	@Tag("boundary")
	public void testMaxPossibleTimeInMillis() {
		long testTime = Long.MAX_VALUE;
		String expected = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ").format(new Date(Long.MAX_VALUE));
		String actualTime = DatabaseSnapshotUtils.dateToString(testTime);
		Assertions.assertEquals(expected, actualTime);
	}

	@Test
	@Tag("invalid")
	public void testNullTimeInMillis() {
		Assertions.assertThrows(NullPointerException.class, () -> DatabaseSnapshotUtils.dateToString(null));
	}

}