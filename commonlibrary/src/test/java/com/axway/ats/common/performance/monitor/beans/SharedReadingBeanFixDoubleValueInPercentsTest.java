/*
 * Copyright 2017 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=fixDoubleValueInPercents_9aebe4b3ec
ROOST_METHOD_SIG_HASH=fixDoubleValueInPercents_edad132dc8

"""
Scenario 1: Test with valid positive double
Details:
  TestName: testFixDoubleValueInPercentsWithValidPositiveDouble
  Description: This test scenario is to check if the provided positive double value is returned correctly after being formatted and multiplied with normalization factor.
Execution:
  Arrange: Declare a positive double value.
  Act: Invoke the fixDoubleValueInPercents with the declared double value.
  Assert: Compare the returned result with the expected formatted output.
Validation:
  The fixDoubleValueInPercents method should return the correct formatted value after being multiplied with normalization factor if a valid positive double value is given. This test verifies correct functionality.

Scenario 2: Test with negative double
Details:
  TestName: testFixDoubleValueInPercentsWithNegativeDouble
  Description: This test scenario is to check if the fixDoubleValueInPercents returns -0.01F as expected when a negative value is provided.
Execution:
  Arrange: Declare negative double value.
  Act: Invoke the fixDoubleValueInPercents with the negative value.
  Assert: Check if the returned value is -0.01F.
Validation:
  The fixDoubleValueInPercents method should return -0.01F for negative values. This is to ensure that values outside the valid range are not passed to further computations or processes.

Scenario 3: Test with NaN
Details:
  TestName: testFixDoubleValueInPercentsWithNaN
  Description: This test scenario is to validate the fixDoubleValueInPercents behavior when NaN is provided.
Execution:
  Arrange: Declare NaN as double.
  Act: Invoke the fixDoubleValueInPercents with NaN value.
  Assert: Check if the returned value is -0.01F.
Validation:
  NaN is not a valid input for percent calculations. In such cases, the method should return -0.01F, ensuring the process does not proceed with an invalid value.

Scenario 4: Test with Infinite value
Details:
  TestName: testFixDoubleValueInPercentsWithInfiniteValue
  Description: This test scenario is to validate the fixDoubleValueInPercents behavior when Infinite is passed.
Execution:
  Arrange: Declare a variable with Infinite value.
  Act: Invoke fixDoubleValueInPercents with the Infinite value.
  Assert: Check if the returned value is -0.01F.
Validation:
  Infinite is not a valid computation value. So, the method needs to handle this situation by returning -0.01F, to prevent propagation of an invalid value downstream.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.performance.monitor.beans;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Locale;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.*;

@ExtendWith(MockitoExtension.class)
public class SharedReadingBeanFixDoubleValueInPercentsTest {

	@Mock
	private SharedReadingBean sharedReadingBean;

	@Mock
	private Logger logMock;

	@BeforeEach
	public void setup() {
		sharedReadingBean = Mockito.spy(new SharedReadingBean("", "", "", 1.0f));
		sharedReadingBean.log = logMock;
	}

	@Test
	@Tag("valid")
	public void testFixDoubleValueInPercentsWithValidPositiveDouble() {
		double testValue = 4.0;
		DecimalFormat formatter = new DecimalFormat("0.00", DecimalFormatSymbols.getInstance(Locale.US));
		float expectedValue = Float.parseFloat(formatter.format(testValue)) * 1.0f;
		assertEquals(expectedValue, sharedReadingBean.fixDoubleValueInPercents(testValue), 0.001);
	}

	@Test
	@Tag("invalid")
	public void testFixDoubleValueInPercentsWithNegativeDouble() {
		double testValue = -5.0;
		assertEquals(-0.01f, sharedReadingBean.fixDoubleValueInPercents(testValue), 0.001);
		verify(logMock, times(1)).warn(any(String.class));
	}

	@Test
	@Tag("invalid")
	public void testFixDoubleValueInPercentsWithNaN() {
		double testValue = Double.NaN;
		assertEquals(-0.01f, sharedReadingBean.fixDoubleValueInPercents(testValue), 0.001);
		verify(logMock, times(1)).warn(any(String.class));
	}

	@Test
	@Tag("invalid")
	public void testFixDoubleValueInPercentsWithInfiniteValue() {
		double testValue = Double.POSITIVE_INFINITY;
		assertEquals(-0.01f, sharedReadingBean.fixDoubleValueInPercents(testValue), 0.001);
		verify(logMock, times(1)).warn(any(String.class));
	}

}