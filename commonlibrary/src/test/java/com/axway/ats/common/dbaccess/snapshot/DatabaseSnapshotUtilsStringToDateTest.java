/*
 * Copyright 2017 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=stringToDate_bcdc9fc64b
ROOST_METHOD_SIG_HASH=stringToDate_12872dc0e6

"""
Scenario 1: Test to validate passing a valid date string to the method
Details:
  TestName: validStringToDateConversion.
  Description: This test scenario is to validate the proper conversion of a valid date string to a long metric. This includes the specific functionality of handling a correct date string format.
Execution:
  Arrange: Provide a valid date string.
  Act: Invoke the stringToDate method.
  Assert: Assert the returned value should match the expected long output.
Validation:
  Test verifies that a valid date string is successfully converted to long. The expected result would be the equivalent date in long format. This test checks for correct parsing and conversion when the input conditions are ideal.

Scenario 2: Test to validate passing an invalid date string to the method
Details:
  TestName: invalidStringToDateConversion.
  Description: This scenario would test if the method is handling invalid inputs correctly. The invalid input in this case is a date string not in the standard format that the application requires.
Execution:
  Arrange: Provide an invalid date string.
  Act: Invoke the stringToDate method.
  Assert: Assert there should be an exception thrown from the method.
Validation:
  Test verifies that for invalid date string inputs, the method throws a DatabaseSnapshotException. This is crucial as it prevents the application from experiencing unhandled exceptions during runtime.

Scenario 3: Test to validate passing a null value to the method
Details:
  TestName: nullStringToDateConversion.
  Description: This test scenario checks the behavior of the method when null inputs are encountered instead of a date string.
Execution:
  Arrange: Provide a null value.
  Act: Invoke the stringToDate method.
  Assert: Assert that an exception is being thrown from the method.
Validation:
  Test verifies that for null inputs, the method throws a DatabaseSnapshotException. Handling null inputs is part of preventive measures against Null Pointer Exceptions during runtime.

Scenario 4: Test to validate passing an empty date string to the stringToDate() method
Details:
  TestName: emptyStringToDateConversion.
  Description: This scenario checks the method's behavior when an empty string is passed instead of a valid date string.
Execution:
  Arrange: Provide an empty string.
  Act: Invoke the stringToDate() method.
  Assert: Assert that an exception is being thrown from the method.
Validation:
  This test verifies that for empty string inputs, the method throws a DatabaseSnapshotException. It is important to validate how the software behaves against unexpected inputs.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.dbaccess.snapshot;

import java.text.SimpleDateFormat;
import java.util.Date;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class DatabaseSnapshotUtilsStringToDateTest {

	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ");

	@Tag("valid")
	@Test
	public void validStringToDateConversion() {
		String validDateString = "2022-01-01 00:00:00.000+0000";
		long expectedOutput = DATE_FORMAT.parse(validDateString).getTime();
		assertEquals(expectedOutput, DatabaseSnapshotUtils.stringToDate(validDateString));
	}

	@Tag("invalid")
	@Test
	public void invalidStringToDateConversion() {
		String invalidDateString = "Invalid Date String";
		assertThrows(DatabaseSnapshotException.class, () -> DatabaseSnapshotUtils.stringToDate(invalidDateString));
	}

	@Tag("boundary")
	@Test
	public void nullStringToDateConversion() {
		assertThrows(DatabaseSnapshotException.class, () -> DatabaseSnapshotUtils.stringToDate(null));
	}

	@Tag("boundary")
	@Test
	public void emptyStringToDateConversion() {
		String emptyDateString = "";
		assertThrows(DatabaseSnapshotException.class, () -> DatabaseSnapshotUtils.stringToDate(emptyDateString));
	}

}