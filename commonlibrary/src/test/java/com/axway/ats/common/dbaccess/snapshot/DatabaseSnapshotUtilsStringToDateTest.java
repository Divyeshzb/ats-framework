/*
 * Copyright 2017 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=stringToDate_bcdc9fc64b
ROOST_METHOD_SIG_HASH=stringToDate_12872dc0e6
"""
Scenario 1: Valid Date String Input
Details:
  TestName: testValidDateStringInput.
  Description: The test is meant to check if the stringToDate method converts a valid date string to epoch millis in a correct manner.
Execution:
  Arrange: Prepare a valid date string in "yyyy-MM-dd HH:mm:ss.SSSZ" format.
  Act: Invoke the stringToDate method by passing the valid date string.
  Assert: Validate if the returned epoch millis is correct.
Validation:
  The assertion verifies that the given date string is parsed correctly to epoch millis based on the provided format. It's significant as it validates the primary functionality of the method.
Scenario 2: Invalid Date String Input
Details:
  TestName: testInvalidDateStringInput.
  Description: The test is meant to check if the stringToDate method handles invalid date strings correctly and throws the expected exception.
Execution:
  Arrange: Prepare an invalid date string that doesn't comply with "yyyy-MM-dd HH:mm:ss.SSSZ" format.
  Act: Invoke the stringToDate method by passing the invalid date string.
  Assert: Check if a DatabaseSnapshotException is thrown with correct error message.
Validation:
  The assertion checks if the exception is thrown when parsing an invalid date string. It stands crucial in handling invalid data by showing meaningful error messages.
Scenario 3: Null Date String Input
Details:
  TestName: testNullDateStringInput.
  Description: The test is meant to verify how the stringToDate method behaves when a null input is given.
Execution:
  Arrange: No need to arrange anything specifically in this case as the input would be null.
  Act: Invoke the stringToDate method with null input.
  Assert: Check if a DatabaseSnapshotException is thrown as parse() method in SimpleDateFormat class will throw a NullPointerException.
Validation:
  The assertion checks how the method handles null inputs and ensures NullPointerException is correctly handled and meaningful DatabaseSnapshotException is thrown instead.
Scenario 4: Empty Date String Input
Details:
  TestName: testEmptyDateStringInput.
  Description: The test verifies how the stringToDate method handles empty input string.
Execution:
  Arrange: Prepare an empty date string.
  Act: Invoke the method with empty string as input.
  Assert: Check if a DatabaseSnapshotException is thrown.
Validation:
  The assertion inspects how the method handles empty string and ensures a correct exception is thrown in response to this scenario, which supports robust error handling mechanism.
"""
*/
// ********RoostGPT********
package com.axway.ats.common.dbaccess.snapshot;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.junit.jupiter.api.*;

@Tag("com.axway.ats.common.dbaccess.snapshot")
@Tag("com.axway.ats.common.dbaccess.snapshot.stringToDate")
public class DatabaseSnapshotUtilsStringToDateTest {

	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ");

	@Tag("valid")
	@Test
	public void testValidDateStringInput() {
		String validDateString = "2021-12-01 15:30:45.123+0530";
		long actualMillis = DatabaseSnapshotUtils.stringToDate(validDateString);
		long expectedMillis = 0;
		try {
			expectedMillis = DATE_FORMAT.parse(validDateString).getTime();
		}
		catch (ParseException e) {
			e.printStackTrace();
		}
		Assertions.assertEquals(expectedMillis, actualMillis);
	}

	@Tag("invalid")
	@Test
	public void testInvalidDateStringInput() {
		String invalidDateString = "invalid date string";
		Exception exception = Assertions.assertThrows(DatabaseSnapshotException.class, () -> {
			DatabaseSnapshotUtils.stringToDate(invalidDateString);
		});
		String expectedMessage = "Cannot parse date '" + invalidDateString + "'";
		String actualMessage = exception.getMessage();
		Assertions.assertTrue(actualMessage.contains(expectedMessage));
	}

	@Tag("boundary")
	@Test
	public void testNullDateStringInput() {
		Exception exception = Assertions.assertThrows(DatabaseSnapshotException.class, () -> {
			DatabaseSnapshotUtils.stringToDate(null);
		});
		String expectedMessage = "Cannot parse date 'null'";
		String actualMessage = exception.getMessage();
		Assertions.assertTrue(actualMessage.contains(expectedMessage));
	}

	@Tag("boundary")
	@Test
	public void testEmptyDateStringInput() {
		String emptyDateString = "";
		Exception exception = Assertions.assertThrows(DatabaseSnapshotException.class, () -> {
			DatabaseSnapshotUtils.stringToDate(emptyDateString);
		});
		String expectedMessage = "Cannot parse date '" + emptyDateString + "'";
		String actualMessage = exception.getMessage();
		Assertions.assertTrue(actualMessage.contains(expectedMessage));
	}

}