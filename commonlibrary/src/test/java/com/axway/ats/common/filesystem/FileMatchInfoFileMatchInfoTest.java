// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=FileMatchInfo_23fca4bb55
ROOST_METHOD_SIG_HASH=FileMatchInfo_465b7c04f3

"""

  Scenario 1: Test when numberOfMatchedLines is zero

  Details:
    TestName: testConstructorWithZeroMatchedLines.
    Description: This test will verify the correct assignment of parameters when the numberOfMatchedLines is zero. In such case the 'matched' parameter is expected to be false.
  Execution:
    Arrange: Initialize all parameters, with numberOfMatchedLines set to 0.
    Act: Invoke the constructor of FileMatchInfo with the initialized parameters.
    Assert: Check if the 'matched' parameter is set to false.
  Validation:
    The assertion confirms that 'matched' is set to false when there are no matched lines. This is expected as 'matched' should be true only if there are any matching lines.


  Scenario 2: Test when numberOfMatchedLines is more than zero

  Details:
    TestName: testConstructorWithPositiveMatchedLines.
    Description: This test will verify the correct assignment of parameters when the numberOfMatchedLines is more than zero. In this case, the 'matched' parameter is expected to be true.
  Execution:
    Arrange: Initialize all parameters, with numberOfMatchedLines set to any positive integer.
    Act: Invoke the constructor of FileMatchInfo with the initialized parameters.
    Assert: Check if the 'matched' parameter is set to true.
  Validation:
    The assertion verifies that 'matched' is true when there are matched lines. This complies with the business logic that matched should be true if any lines match.


  Scenario 3: Test when lines, lineNumbers and matchedPatterns arrays are null

  Details:
    TestName: testConstructorWithNullArrays.
    Description: This test checks the assignment of lines, lineNumbers, and matchedPatterns when they are null.
  Execution:
    Arrange: Initialize all parameters, with lines, lineNumbers, and matchedPatterns set to null.
    Act: Invoke the constructor of FileMatchInfo with the initialized parameters.
    Assert: Check if the arrays - lines, lineNumbers, and matchedPatterns are assigned null successfully.
  Validation:
    The assertion verifies the correct assignment of null value to the arrays in the constructor method. It's important to ensure null inputs are handled gracefully without causing any exceptions.


  Scenario 4: Test when lastReadLineNumber and lastReadByte are negative

  Details:
    TestName: testConstructorWithNegativeLastReadValues.
    Description: This test checks the assignment of lastReadLineNumber and lastReadByte when their values are negative.
  Execution:
    Arrange: Initialize all parameters, with lastReadLineNumber and lastReadByte set to a negative integer.
    Act: Invoke the constructor of FileMatchInfo with the initialized parameters.
    Assert: Check if lastReadLineNumber and lastReadByte are assigned the negative values successfully.
  Validation:
    The assertion verifies the correct assignment of negative values to lastReadLineNumber and lastReadByte. Handling this edge case is critical as line number and byte count usually cannot be negative, and it will help to identify any bugs or malfunctions in the program.


  Scenario 5: Test when input arrays have different sizes

  Details:
    TestName: testConstructorWithDifferentSizedArrays.
    Description: This test checks if the constructor can handle the case where the size of the lineNumbers, lines, and matchedPatterns arrays are not equal, which is a potential scenario.
  Execution:
    Arrange: Initialize all parameters, with lines, lineNumbers, and matchedPatterns having different sizes.
    Act: Invoke the constructor of FileMatchInfo with the initialized parameters.
    Assert: No assertions can be made as it is unspecified how such a scenario should be handled.
  Validation:
    This scenario is meant to expose potential bugs in cases where the size of the arrays being passed are not equal. Depending on the functional requirements, suitable actions should be taken for such scenarios, and additional test cases can then be built around that.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.filesystem;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.io.Serializable;
import com.axway.ats.common.PublicAtsApi;

public class FileMatchInfoFileMatchInfoTest {

	@Test
	@Tag("boundary")
	public void testConstructorWithZeroMatchedLines() {
		int numberOfMatchedLines = 0;
		int lastReadLineNumber = 5;
		long lastReadByte = 1L;
		String[] lines = { "test" };
		Integer[] lineNumbers = { 1 };
		String[] matchedPatterns = { "pattern" };
		FileMatchInfo fileMatchInfo = new FileMatchInfo(numberOfMatchedLines, lastReadLineNumber, lastReadByte, lines,
				lineNumbers, matchedPatterns);
		assertFalse(fileMatchInfo.matched);
	}

	@Test
	@Tag("valid")
	public void testConstructorWithPositiveMatchedLines() {
		int numberOfMatchedLines = 5;
		int lastReadLineNumber = 5;
		long lastReadByte = 1L;
		String[] lines = { "test" };
		Integer[] lineNumbers = { 1 };
		String[] matchedPatterns = { "pattern" };
		FileMatchInfo fileMatchInfo = new FileMatchInfo(numberOfMatchedLines, lastReadLineNumber, lastReadByte, lines,
				lineNumbers, matchedPatterns);
		assertTrue(fileMatchInfo.matched);
	}

	@Test
	@Tag("valid")
	public void testConstructorWithNullArrays() {
		int numberOfMatchedLines = 0;
		int lastReadLineNumber = 5;
		long lastReadByte = 1L;
		String[] lines = null;
		Integer[] lineNumbers = null;
		String[] matchedPatterns = null;
		FileMatchInfo fileMatchInfo = new FileMatchInfo(numberOfMatchedLines, lastReadLineNumber, lastReadByte, lines,
				lineNumbers, matchedPatterns);
		assertNull(fileMatchInfo.lines);
		assertNull(fileMatchInfo.lineNumbers);
		assertNull(fileMatchInfo.matchedPatterns);
	}

	@Test
	@Tag("boundary")
	public void testConstructorWithNegativeLastReadValues() {
		int numberOfMatchedLines = 0;
		int lastReadLineNumber = -5;
		long lastReadByte = -1L;
		String[] lines = { "test" };
		Integer[] lineNumbers = { 1 };
		String[] matchedPatterns = { "pattern" };
		FileMatchInfo fileMatchInfo = new FileMatchInfo(numberOfMatchedLines, lastReadLineNumber, lastReadByte, lines,
				lineNumbers, matchedPatterns);
		assertEquals(-5, fileMatchInfo.lastReadLineNumber);
		assertEquals(-1, fileMatchInfo.lastReadByte);
	}

	@Test
	@Tag("invalid")
	public void testConstructorWithDifferentSizedArrays() {
		int numberOfMatchedLines = 0;
		int lastReadLineNumber = 5;
		long lastReadByte = 1L;
		String[] lines = { "test", "test2" };
		Integer[] lineNumbers = { 1 };
		String[] matchedPatterns = { "pattern", "pattern1", "pattern2" };
		assertDoesNotThrow(() -> {
			new FileMatchInfo(numberOfMatchedLines, lastReadLineNumber, lastReadByte, lines, lineNumbers,
					matchedPatterns);
		});
	}

}