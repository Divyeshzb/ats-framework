/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=clearRowsPresentedInOneSnapshotOnly_b2daa743f2
ROOST_METHOD_SIG_HASH=clearRowsPresentedInOneSnapshotOnly_cc7b4d5a1c

"""
Scenario 1: Clearing rows from a table present only in the first snapshot

Details:
  TestName: testClearRowsFromFirstSnapshotTable.
  Description: This test case checks if the method correctly removes the specified table entries from the first snapshot only.
Execution:
  Arrange: Assign the firstSnapshotName and add a tableName to the first snapshot using addRowPresentInOneSnapshotOnly() method.
  Act: Invoke the clearRowsPresentedInOneSnapshotOnly method with the specified tableName.
  Assert: Use JUnit assertions to confirm that the table no longer exists in the first snapshot rowPresentInOneSnapshotOnly map.
Validation:
  The test is designed to verify that the method accurately removes tables from the first snapshot only. The expected result is that the table will no longer be present in the rowPresentInOneSnapshotOnly map for the first snapshot.

Scenario 2: Clearing rows from a table present only in the second snapshot

Details:
  TestName: testClearRowsFromSecondSnapshotTable.
  Description: This test case checks if the method correctly removes the specified table entries from the second snapshot only.
Execution:
  Arrange: Assign the secondSnapshotName and add a tableName to the second snapshot using addRowPresentInOneSnapshotOnly() method.
  Act: Invoke the clearRowsPresentedInOneSnapshotOnly method with the specified tableName.
  Assert: Use JUnit assertions to confirm that the table no longer exists in the second snapshot rowPresentInOneSnapshotOnly map.
Validation:
  The test verifies that the method accurately removes tables from the second snapshot only. The expected result is that the table will no longer be present in the rowPresentInOneSnapshotOnly map for the second snapshot.

Scenario 3: Attempting to clear rows from a non-existent table

Details:
  TestName: testClearRowsFromNonExistentTable.
  Description: This test case checks if the method handles the scenario where the specified table does not exist in either snapshot.
Execution:
  Arrange: Assign firstSnapshotName and secondSnapshotName without adding any tables to either snapshot.
  Act: Invoke the clearRowsPresentedInOneSnapshotOnly method with a tableName that does not exist in either snapshot.
  Assert: Use JUnit assertions to confirm that the rowPresentInOneSnapshotOnly maps for both the first and second snapshot remain unchanged.
Validation:
  The test checks the method's ability to handle invalid input gracefully. The expected result is no change in the rowPresentInOneSnapshotOnly maps for both the first and second snapshot as the specified table was never added.

Scenario 4: Clearing a row from table present in both first and second snapshot

Details:
  TestName: testClearRowsFromTableInBothSnapShots.
  Description: This test case tests if the method correctly removes rows from a table present in both snapshots.
Execution:
  Arrange: Assign values to firstSnapshotName and secondSnapshotName and add a tableName to both using addRowPresentInOneSnapshotOnly() method.
  Act: Invoke the clearRowsPresentedInOneSnapshotOnly method with the specified tableName.
  Assert: Use JUnit assertions to verify that the table does not exist anymore in rowPresentInOneSnapshotOnly maps of both snapshots.
Validation:
  The test verifies the method's ability to clear rows from a table present in both snapshots. The expected result is the table being removed from the rowPresentInOneSnapshotOnly maps of both snapshots.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.dbaccess.snapshot.equality;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import com.axway.ats.common.PublicAtsApi;

class DatabaseEqualityStateClearRowsPresentedInOneSnapshotOnlyTest {

	private DatabaseEqualityState databaseEqualityState;

	String firstSnapshotName = "firstSnapshot";

	String secondSnapshotName = "secondSnapshot";

	String tableName = "table1";

	@BeforeEach
	void setUp() {
		databaseEqualityState = new DatabaseEqualityState(firstSnapshotName, secondSnapshotName);
	}

	@Test
	@Tag("valid")
	void testClearRowsFromFirstSnapshotTable() {
		databaseEqualityState.addRowPresentInOneSnapshotOnly(firstSnapshotName, tableName, "rowValues");
		databaseEqualityState.clearRowsPresentedInOneSnapshotOnly(tableName);
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(firstSnapshotName).contains(tableName));
	}

	@Test
	@Tag("valid")
	void testClearRowsFromSecondSnapshotTable() {
		databaseEqualityState.addRowPresentInOneSnapshotOnly(secondSnapshotName, tableName, "rowValues");
		databaseEqualityState.clearRowsPresentedInOneSnapshotOnly(tableName);
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(secondSnapshotName).contains(tableName));
	}

	@Test
	@Tag("invalid")
	void testClearRowsFromNonExistentTable() {
		databaseEqualityState.clearRowsPresentedInOneSnapshotOnly(tableName);
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(firstSnapshotName).contains(tableName));
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(secondSnapshotName).contains(tableName));
	}

	@Test
	@Tag("valid")
	void testClearRowsFromTableInBothSnapShots() {
		databaseEqualityState.addRowPresentInOneSnapshotOnly(firstSnapshotName, tableName, "rowValues");
		databaseEqualityState.addRowPresentInOneSnapshotOnly(secondSnapshotName, tableName, "rowValues");
		databaseEqualityState.clearRowsPresentedInOneSnapshotOnly(tableName);
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(firstSnapshotName).contains(tableName));
		assertFalse(
				databaseEqualityState.getRowsPresentInOneSnapshotOnlyAsStrings(secondSnapshotName).contains(tableName));
	}

}