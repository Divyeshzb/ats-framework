/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=clearRowsPresentedInOneSnapshotOnly_b2daa743f2
ROOST_METHOD_SIG_HASH=clearRowsPresentedInOneSnapshotOnly_cc7b4d5a1c
"""
  Scenario 1: Test the clearRowsPresentedInOneSnapshotOnly method with valid tableName and it exists in first Snapshot.
  Details:
    TestName: validateClearRowsFromFirstSnapshot.
    Description: This test aims to check the functionality of clearing rows from the firstSnapshot map represented by tableName.
  Execution:
    Arrange: Create a firstSnapshotName, secondSnapshotName, and rowPresentInOneSnapshotOnly map. Set a valid tableName to both the firstSnapshotName and secondSnapshotName map.
    Act: Invoke clearRowsPresentedInOneSnapshotOnly method with the created tableName.
    Assert: Assert whether the rowPresentInOneSnapshotOnly map no longer contains the tableName under the firstSnapshotName.
  Validation:
    If the test runs successfully, the row identified by tableName in the firstSnapshotName would have been removed by the clearRowsPresentedInOneSnapshotOnly method.
  Scenario 2: Test the clearRowsPresentedInOneSnapshotOnly method with valid tableName and it exists in second Snapshot.
  Details:
    TestName: validateClearRowsFromSecondSnapshot.
    Description: This test aims to check the functionality of clearing rows from the secondSnapshot map represented by tableName.
  Execution:
    Arrange: Create a firstSnapshotName, secondSnapshotName, and rowPresentInOneSnapshotOnly map. Set a valid tableName to both the firstSnapshotName and secondSnapshotName map.
    Act: Invoke clearRowsPresentedInOneSnapshotOnly method with the created tableName.
    Assert: Assert whether the rowPresentInOneSnapshotOnly map no longer contains the tableName under the secondSnapshotName.
  Validation:
    If the test runs successfully, the row identified by tableName in the secondSnapshotName would have been removed by the clearRowsPresentedInOneSnapshotOnly method.
  Scenario 3: Test the clearRowsPresentedInOneSnapshotOnly method when the tableName doesn't exist in any snapshots.
  Details:
    TestName: validateWithNonexistentTableName.
    Description: This test aims to check the functionality when the table doesn't exist in either the first or the second snapshot.
  Execution:
    Arrange: Create a firstSnapshotName, secondSnapshotName, and rowPresentInOneSnapshotOnly map. Set a valid tableName to neither the firstSnapshotName nor the secondSnapshotName map.
    Act: Invoke clearRowsPresentedInOneSnapshotOnly method with the created tableName.
    Assert: Assert whether the rowPresentInOneSnapshotOnly map size remains the same after the method invocation.
  Validation:
    The table identified by tableName doesn't exist in any snapshot. Hence, the method invocation doesn't have any impact on the snapshots and the test validates this.
  Scenario 4: Test the clearRowsPresentedInOneSnapshotOnly method when the tableName exists in both snapshots.
  Details:
    TestName: validateWithTableNameInBothSnapshots.
    Description: This test aims to check the functionality where a table exists in both snapshots.
  Execution:
    Arrange: Create a firstSnapshotName, secondSnapshotName, and rowPresentInOneSnapshotOnly map. Set a valid tableName to both the firstSnapshotName and secondSnapshotName map.
    Act: Invoke clearRowsPresentedInOneSnapshotOnly method with the created tableName.
    Assert: Check whether tableName has been removed from both the snapshots.
  Validation:
    The test would pass if the table identified by tableName, which initially exists in both snapshots, is removed from both after the method execution.
 """
*/
// ********RoostGPT********
package com.axway.ats.common.dbaccess.snapshot.equality;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import com.axway.ats.common.PublicAtsApi;
import org.junit.jupiter.api.*;

@Tag("com.axway.ats.common.dbaccess.snapshot.equality")
@Tag("com.axway.ats.common.dbaccess.snapshot.equality.clearRowsPresentedInOneSnapshotOnly")
@PublicAtsApi
public class DatabaseEqualityStateClearRowsPresentedInOneSnapshotOnlyTest {

	private String firstSnapshotName;

	private String secondSnapshotName;

	private Map<String, Map<String, List<String>>> rowPresentInOneSnapshotOnly;

	@BeforeEach
	public void setUp() {
		firstSnapshotName = "FirstSnapshot";
		secondSnapshotName = "SecondSnapshot";

		rowPresentInOneSnapshotOnly = new TreeMap<>();

		Map<String, List<String>> firstSnapshotMap = new TreeMap<>();
		Map<String, List<String>> secondSnapshotMap = new TreeMap<>();
		List<String> tableRows1 = new ArrayList<>();
		tableRows1.add("Row1");
		List<String> tableRows2 = new ArrayList<>();
		tableRows1.add("Row2");

		firstSnapshotMap.put("Table1", tableRows1);
		secondSnapshotMap.put("Table2", tableRows2);

		rowPresentInOneSnapshotOnly.put(firstSnapshotName, firstSnapshotMap);
		rowPresentInOneSnapshotOnly.put(secondSnapshotName, secondSnapshotMap);
	}

	@Tag('valid')
    @Test
    public void validateClearRowsFromFirstSnapshot(){
        String tableName = "Table1";
        clearRowsPresentedInOneSnapshotOnly(tableName);
        assertFalse(rowPresentInOneSnapshotOnly.get(firstSnapshotName).containsKey(tableName));
    }

	@Tag
	('valid')@Test public void validateClearRowsFromSecondSnapshot() {
		String tableName = "Table2";
		clearRowsPresentedInOneSnapshotOnly(tableName);
		assertFalse(rowPresentInOneSnapshotOnly.get(secondSnapshotName).containsKey(tableName));
	}

	@Tag
	('invalid')@Test public void validateWithNonexistentTableName() {
		int initialSize = rowPresentInOneSnapshotOnly.size();
		String tableName = "NonexistentTable";
		clearRowsPresentedInOneSnapshotOnly(tableName);
		assertEquals(initialSize, rowPresentInOneSnapshotOnly.size());
	}

	@Tag
	('valid')@Test public void validateWithTableNameInBothSnapshots() {
		String tableName = "Table1";

		rowPresentInOneSnapshotOnly.get(secondSnapshotName).put(tableName, new ArrayList<>());

		clearRowsPresentedInOneSnapshotOnly(tableName);

		assertFalse(rowPresentInOneSnapshotOnly.get(firstSnapshotName).containsKey(tableName));
		assertFalse(rowPresentInOneSnapshotOnly.get(secondSnapshotName).containsKey(tableName));
	}

}