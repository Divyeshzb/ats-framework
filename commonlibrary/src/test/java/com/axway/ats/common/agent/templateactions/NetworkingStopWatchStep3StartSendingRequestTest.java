// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=step3_StartSendingRequest_8771b1abe0
ROOST_METHOD_SIG_HASH=step3_StartSendingRequest_d236746bdc

"""
  Scenario 1: Verify if Net and Server Processing Timer resumes properly
  Details:
    TestName: shouldResumeTimerWhenStep3MethodCalled
    Description: This test is designed to ensure that when the `step3_StartSendingRequest` method is invoked, the net and server processing timer resumes as expected.
  Execution:
    Arrange: Initialize the `NetworkingStopWatch` object and invoke the `step1_OpenConnectionForRequest` method followed by the `step2_OpenedConnectionForRequest` method.
    Act: Invoke the `step3_StartSendingRequest` method.
    Assert: Verify if the time recorded by `getNetworkingTime` method has increased compared to the initial state. This indicates that the net and server processing timer has indeed resumed.
  Validation:
    The assertion verifies that the net and server processing timer resumes when the `step3_StartSendingRequest` method is invoked. This is critical for accurate tracking of operations' times in a communication system.

  Scenario 2: Confirm No Side Impact on Timer Between Request and Response
  Details:
    TestName: shouldNotImpactTimerBetweenReqAndResponse
    Description: This test is designed to ensure that the `step3_StartSendingRequest` method does not impact the timer between request and response.
  Execution:
    Arrange: Initialize the `NetworkingStopWatch` and start the timer between request and response using the method `step5_StartInterimTimer`. Record the initial timer between request and response.
    Act: Invoke the `step3_StartSendingRequest` method.
    Assert: Compare the initial timer between request and response time using `getTimeBetweenReqAndResponse` method with the time after `step3_StartSendingRequest` is called; they should be equal.
  Validation:
    The assertion verifies that `step3_StartSendingRequest` does not modify the time between request and response. This helps maintain the consistency and integrity of time measurements.

  Scenario 3: Test method when Net and Server Processing Time is not initially started
  Details:
    TestName: shouldThrowExceptionWhenTimerNotStarted
    Description: This test is designed to ensure that the `step3_StartSendingRequest` method throws an exception when the net and server processing timer hasn't been started beforehand.
  Execution:
    Arrange: Initialize the `NetworkingStopWatch` object.
    Act: Invoke the `step3_StartSendingRequest` method without starting the net and server processing time.
    Assert: Expect a RuntimeException or an equivalent error.
  Validation:
    This assertion ensures that an exception is thrown when attempting to resume an uninitialized timer. This is crucial as it would prevent inaccurate or misleading time metrics.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.agent.templateactions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.apache.commons.lang3.time.StopWatch;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.*;
import org.apache.log4j.Logger;

class NetworkingStopWatchStep3StartSendingRequestTest {

	private NetworkingStopWatch networkingStopWatch;

	@BeforeEach
	public void setUp() {
		networkingStopWatch = new NetworkingStopWatch("TestAction");
	}

	@Test
	@Tag("valid")
	void shouldResumeTimerWhenStep3MethodCalled() {
		networkingStopWatch.step1_OpenConnectionForRequest();
		networkingStopWatch.step2_OpenedConnectionForRequest();
		long initialTime = networkingStopWatch.getNetworkingTime();
		networkingStopWatch.step3_StartSendingRequest();
		long finalTime = networkingStopWatch.getNetworkingTime();
		Assertions.assertThat(finalTime).isGreaterThan(initialTime);
	}

	@Test
	@Tag("valid")
	void shouldNotImpactTimerBetweenReqAndResponse() {
		networkingStopWatch.step5_StartInterimTimer();
		long initialTimerBetweenReqAndResp = networkingStopWatch.getTimeBetweenReqAndResponse();
		networkingStopWatch.step3_StartSendingRequest();
		long finalTimerBetweenReqAndResp = networkingStopWatch.getTimeBetweenReqAndResponse();
		Assertions.assertThat(finalTimerBetweenReqAndResp).isEqualTo(initialTimerBetweenReqAndResp);
	}

	@Test
	@Tag("invalid")
	void shouldThrowExceptionWhenTimerNotStarted() {
		Assertions.assertThatThrownBy(() -> networkingStopWatch.step3_StartSendingRequest())
			.isInstanceOf(RuntimeException.class);
	}

}