/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=getTablesWithColumnsPresentInOneSnapshotOnly_fc97c465e9
ROOST_METHOD_SIG_HASH=getTablesWithColumnsPresentInOneSnapshotOnly_15f7ca2b1d

"""
Scenario 1: Testing with Valid Snapshot Name

Details:
TestName: testWithValidSnapshotName
Description: Test the 'getTablesWithColumnsPresentInOneSnapshotOnly' method with a valid snapshot name. The name is assumed to be valid if there exists snapshot data associated with it.
Execution:
Arrange: Generate a valid snapshot name and make sure there is associated data.
Act: Invoke 'getTablesWithColumnsPresentInOneSnapshotOnly' method with the valid snapshot name.
Assert: Verify that the returned list of tables would correctly reflect the tables with columns present in that snapshot only.
Validation:
The validation checks the functionality of the method when given valid inputs. The expected result should be a list of tables that only exist in the given snapshot. The significance of this test checks the method's ability to accurately filter unique tables based on column's presence.

Scenario 2: Testing with Invalid Snapshot Name

Details:
TestName: testWithInvalidSnapshotName
Description: Test the 'getTablesWithColumnsPresentInOneSnapshotOnly' method with a non-existent snapshot name.
Execution:
Arrange: Generate a snapshot name that doesn't exist in the current database configuration.
Act: Invoke 'getTablesWithColumnsPresentInOneSnapshotOnly' method with the non-existent snapshot name.
Assert: Verify that the returned list is empty as no tables exist with columns present in the non-existing snapshot.
Validation:
Given an invalid snapshot name, the method should return an empty list as there's no associated data. This test ensures the method handles invalid arguments correctly, preventing potential application failure.

Scenario 3: Testing with Null Snapshot Name

Details:
TestName: testWithNullSnapshotName
Description: Test the 'getTablesWithColumnsPresentInOneSnapshotOnly' method with a null snapshot name. This is a negative test case expected to throw an exception.
Execution:
Arrange: Pass null value as an argument.
Act: Invoke 'getTablesWithColumnsPresentInOneSnapshotOnly' method with the null snapshot name.
Assert: Check if the method throws a NullPointerException or a customized exception that deals with null input.
Validation:
The method should not accept null as an argument, and an exception should be thrown. This test covers the edge case of receiving null input.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.dbaccess.snapshot.equality;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.BeforeEach;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import com.axway.ats.common.PublicAtsApi;

public class DatabaseEqualityStateGetTablesWithColumnsPresentInOneSnapshotOnlyTest {

	private DatabaseEqualityState databaseEqualityState;

	private String validSnapshotName;

	private String nonExistentSnapshotName;

	@BeforeEach
	public void setup() {
		validSnapshotName = "validSnapshot";
		nonExistentSnapshotName = "invalidSnapshot";
		databaseEqualityState = new DatabaseEqualityState(validSnapshotName, "secondSnapshot");
		Map<String, List<String>> tablesPerSnapshot = new TreeMap<>();
		List<String> columns = new ArrayList<>(Arrays.asList("column1", "column2"));
		tablesPerSnapshot.put("table1", columns);
		Map<String, Map<String, List<String>>> columnPresentInOneSnapshotOnly = new TreeMap<>();
		columnPresentInOneSnapshotOnly.put(validSnapshotName, tablesPerSnapshot);
		databaseEqualityState.columnPresentInOneSnapshotOnly = columnPresentInOneSnapshotOnly;
	}

	@Test
	@Tag("valid")
	public void testWithValidSnapshotName() {
		List<String> tables = databaseEqualityState.getTablesWithColumnsPresentInOneSnapshotOnly(validSnapshotName);
		assertEquals(1, tables.size());
		assertTrue(tables.contains("table1"));
	}

	@Test
	@Tag("invalid")
	public void testWithInvalidSnapshotName() {
		List<String> tables = databaseEqualityState
			.getTablesWithColumnsPresentInOneSnapshotOnly(nonExistentSnapshotName);
		assertEquals(0, tables.size());
	}

	@Test
	@Tag("boundary")
	public void testWithNullSnapshotName() {
		Exception exception = assertThrows(NullPointerException.class, () -> {
			databaseEqualityState.getTablesWithColumnsPresentInOneSnapshotOnly(null);
		});
		String expectedMessage = "Snapshot name can't be null";
		String actualMessage = exception.getMessage();
		assertTrue(actualMessage.contains(expectedMessage));
	}

}