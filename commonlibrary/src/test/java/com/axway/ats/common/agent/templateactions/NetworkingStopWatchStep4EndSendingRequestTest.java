// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type  and AI Model

ROOST_METHOD_HASH=step4_EndSendingRequest_acfcf80d3b
ROOST_METHOD_SIG_HASH=step4_EndSendingRequest_9890573019

"""
  Scenario 1: Test when the step4_EndSendingRequest method is called

  Details:
    TestName: invokeStep4EndSendingRequest.
    Description: The test aims to verify the state of timerNetAndServerProcessingTime after calling the step4_EndSendingRequest method. The inner working of this method suggests that it suspends the timer, thus freezing the time.
  Execution:
    Arrange: Initialize the NetworkingStopWatch object. Call previous step methods in the correct sequence up to the step4_EndSendingRequest.
    Act: Call the step4_EndSendingRequest method.
    Assert: Check if timerNetAndServerProcessingTime is suspended after its call.
  Validation:
    The assertion checks if the timerNetAndServerProcessingTime is effectively put on hold after the invocation of step4_EndSendingRequest method. The test will help in validating the correct behaviour of Stopwatch phase transitions of the NetworkingStopWatch object.

  Scenario 2: Confirm the execution order of the 'step4_EndSendingRequest' method

  Details:
    TestName: testExecutionOrderAfterStep4EndSendingRequest.
    Description: This test is intended to validate that the 'step4_EndSendingRequest' method must only be called after certain methods (like step3_StartSendingRequest) are previously executed.
  Execution:
    Arrange: Initialize the NetworkingStopWatch object. Omit or break the sequence of the previous step method calls before step4_EndSendingRequest.
    Act: Now, call the step4_EndSendingRequest method.
    Assert: Capture any potential exceptions/errors that may occur due to incorrect sequence of steps.
  Validation:
    The assertion aims to confirm that step4_EndSendingRequest operation is dependent on prior executions of certain methods and it can trigger exceptions when the sequence is violated. This is crucial to establish the proper functioning of the NetworkingStopWatch class and it's dependencies on certain sequences.

  Scenario 3: Test the duration of timerNetAndServerProcessingTime after execution of step4_EndSendingRequest

  Details:
    TestName: validateDurationAfterStep4EndSendingRequest.
    Description: The test aims to validate if the duration of timerNetAndServerProcessingTime remains unchanged after the invocation of step4_EndSendingRequest.
  Execution:
    Arrange: Initialize the NetworkingStopWatch object. Call preceding steps before invoking step4_EndSendingRequest and note the duration of timerNetAndServerProcessingTime right before step4_EndSendingRequest execution.
    Act: Call step4_EndSendingRequest method.
    Assert: Compare the duration of timerNetAndServerProcessingTime after step4_EndSendingRequest with that of before its execution.
  Validation:
    By validating that the duration of timerNetAndServerProcessingTime remains unchanged after step4_EndSendingRequest, we are essentially ensuring that this method correctly functions to suspend the timer and halt the progression of time.
"""
*/

// ********RoostGPT********

package com.axway.ats.common.agent.templateactions;

import org.apache.commons.lang3.time.StopWatch;
import org.apache.log4j.Logger;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.junit.jupiter.api.*;

public class NetworkingStopWatchStep4EndSendingRequestTest {

	public static final String netTimeLoggerStr = "com.axway.ats.common.agent.templateactions.wireTimer";

	public static final Logger logTimer = Logger.getLogger(netTimeLoggerStr);

	@Test
	@Tag("valid")
	public void invokeStep4EndSendingRequest() {
		NetworkingStopWatch nsw = new NetworkingStopWatch("testAction");
		nsw.step1_OpenConnectionForRequest();
		nsw.step2_OpenedConnectionForRequest();
		nsw.step3_StartSendingRequest();
		nsw.step4_EndSendingRequest();
		Assertions.assertFalse(nsw.getNetTimer().isStarted(), "Network Timer should be suspended after step 4");
	}

	@Test
	@Tag("invalid")
	public void testExecutionOrderAfterStep4EndSendingRequest() {
		NetworkingStopWatch nsw = new NetworkingStopWatch("testAction");
		Executable closureContainingCodeToTest = () -> nsw.step4_EndSendingRequest();
		Assertions.assertThrows(IllegalStateException.class, closureContainingCodeToTest,
				"Expected step4_EndSendingRequest to throw, but it didn't");
	}

	@Test
	@Tag("valid")
	public void validateDurationAfterStep4EndSendingRequest() {
		NetworkingStopWatch nsw = new NetworkingStopWatch("testAction");
		nsw.step1_OpenConnectionForRequest();
		nsw.step2_OpenedConnectionForRequest();
		nsw.step3_StartSendingRequest();
		long durationBefore = nsw.getNetworkingTime();
		nsw.step4_EndSendingRequest();
		long durationAfter = nsw.getNetworkingTime();
		Assertions.assertEquals(durationBefore, durationAfter, "Duration should be same before and after step 4");
	}

}