/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ********RoostGPT********
/*
Test generated by RoostGPT for test axway-java-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=getTablesWithDifferentPrimaryKeys_7f6678ab32
ROOST_METHOD_SIG_HASH=getTablesWithDifferentPrimaryKeys_f12f3a3422
"""
Scenario 1: Successful Retrieval of Tables with Different Primary Keys
Details:
    TestName: testGetTablesWithDifferentPrimaryKeys
    Description: This test checks the proper retrieval of tables with different primary keys given a specific snapshot. It is meant to examine the basic functionality of the method under normal circumstances.
    Execution:
        Arrange: Create known Map of different primary keys and add it to instance variable differentPrimaryKeys.
        Act: Invoke getTablesWithDifferentPrimaryKeys with a snapshot key that exists in differentPrimaryKeys.
        Assert: List of tables associated to the snapshot key should be returned.
    Validation:
        This verifies that the method correctly fetches and returns list of table names tied to specific snapshot. If the snapshot does not exist in differentPrimaryKeys, an empty list is returned.
Scenario 2: Tables List is Empty for Existing Snapshot
Details:
    TestName: testEmptyTablesForExistingSnapshot
    Description: This test scenario checks if the method can handle and return an empty list when the snapshot is in differentPrimaryKeys map but there are no table names associated with it.
    Execution:
        Arrange: Create Map for different primary keys with a snapshot key but no table names (empty Map) and add it to instance variable differentPrimaryKeys.
        Act: Invoke getTablesWithDifferentPrimaryKeys with the aforementioned snapshot.
        Assert: An empty list should be returned.
    Validation:
        This verifies that the method can correctly handle and return an empty list in case the given snapshot has no tables associated with it.
Scenario 3: Snapshot Does Not Exist in differentPrimaryKeys Map
Details:
    TestName: testNonExistingSnapshot
    Description: This test validates the method's ability to handle non-existing snapshots within the differentPrimaryKeys map.
    Execution:
        Arrange: Create Map for different primary keys without a certain snapshot key value pair.
        Act: Invoke getTablesWithDifferentPrimaryKeys with the snapshot that doesn't exist within the map.
        Assert: An empty list should be returned..
    Validation:
        This verifies the method's ability to handle a non-existent snapshot within the DifferentPrimaryKeys map. It should return an empty list, and not crash or throw exceptions.
"""
*/
// ********RoostGPT********
package com.axway.ats.common.dbaccess.snapshot.equality;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import com.axway.ats.common.PublicAtsApi;
import org.junit.jupiter.api.*;

@Tag("com.axway.ats.common.dbaccess.snapshot.equality")
@Tag("com.axway.ats.common.dbaccess.snapshot.equality.getTablesWithDifferentPrimaryKeys")
class DatabaseEqualityStateGetTablesWithDifferentPrimaryKeysTest {

	private DatabaseEqualityState databaseEqualityState;

	private String firstSnapshotName = "firstSnapshot";

	private String secondSnapshotName = "secondSnapshot";

	@BeforeEach
	void setUp() {
		databaseEqualityState = new DatabaseEqualityState(firstSnapshotName, secondSnapshotName);
	}

	@Test
	@Tag("valid")
	void testGetTablesWithDifferentPrimaryKeys() {
		Map<String, Map<String, String>> primaryKeys = new TreeMap<>();
		Map<String, String> primaryKeysData = new TreeMap<>();
		primaryKeysData.put("table1", "key1");
		primaryKeysData.put("table2", "key2");
		primaryKeys.put(firstSnapshotName, primaryKeysData);
		databaseEqualityState.differentPrimaryKeys = primaryKeys;
		List<String> returnTables = databaseEqualityState.getTablesWithDifferentPrimaryKeys(firstSnapshotName);
		List<String> expectedTables = new ArrayList<>(primaryKeysData.keySet());
		assertNotNull(returnTables);
		assertIterableEquals(expectedTables, returnTables);
	}

	@Test
	@Tag("boundary")
	void testEmptyTablesForExistingSnapshot() {
		Map<String, Map<String, String>> primaryKeys = new TreeMap<>();
		primaryKeys.put(firstSnapshotName, new TreeMap<>());
		databaseEqualityState.differentPrimaryKeys = primaryKeys;
		List<String> returnTables = databaseEqualityState.getTablesWithDifferentPrimaryKeys(firstSnapshotName);

		assertTrue(returnTables.isEmpty());
	}

	@Test
	@Tag("invalid")
	void testNonExistingSnapshot() {
		databaseEqualityState.differentPrimaryKeys = new TreeMap<>();
		List<String> returnTables = databaseEqualityState.getTablesWithDifferentPrimaryKeys("nonExistingSnapshot");

		assertTrue(returnTables.isEmpty());
	}

}